# Трехцветный светодиод

Трехцветный светодиод содержит в себе синий, зеленый и красный. Если смешать в разных насыщенностях каждый из них, можно получить практически любой цвет. 

Если смешать красный и синий, получим пурпурный цвет (фуксия), если смешать синий и зеленый, получим сине-зеленый или бирюзовый цвет. А если смешать красный и зеленый, то получим желтый.

![rgb](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/src/rgb.jpg)

У светодиода 4 ноги - три для каждого цвета и одна общая на землю (самая длинная). Мы будем их подключать к ШИМ пинам ардуино, чтобы плавно увеличивать и уменьшать яркость каждого из цветов, таким образом мы сможем сделать переливы.

Светодиод можно зажигать с помощью `digitalWrite` (на полную яркость), либо с помощью `analogWrite` (если соединены к пинам ШИМ), выбрав отдельную яркость для каждого из 3х цветов.

План такой: 
0) Предварительно зажигаем красный.
1) Плавно зажигаем синий. При зажженном красном и синем получим пурпурный.
2) Плавно гасим красный. Остается только синий.
3) Плавно зажигаем зеленый. При зажженном синем и зеленом получим бирюзовый.
4) Плавно гасим синий. Остается только зеленый.
5) Плавно зажигаем красный. При зажженном красном и зеленом получим желтый.
6) Плавно гасим зеленый. Остается только красный.
Возвращаемся к п.1 нашего цикла.

Для каждого шага нам необходимо плавно уменьшать или увеличивать яркость светодиода. Для этого воспользуемся циклом от 0 до 255 или от 255 до 0 и в нем с помощью `analogWrite` будем изменять яркость. Но тогда код получится большим и сложночитаемым. Самый верный вариант - это создать процедуру, которая будет плавно зажигать светодиод или плавно его гасить, а в программе просто вызывать данную процедуру.
Назовем процедуру smooth (плавный по английски), она будет выглядеть так:

```C++
// Процедура для плавного перелива. Указываем с какого значения до какого
//  увеличивать (или уменьшать) значение на 1.
void smooth(int pin, int from, int to) {
  // Будем изменять переменную from до тех пор, пока она не станет равной переменной to
  // Сделаем копию переменной from, назовем ее c и будем работать с ней
  int c = from;
  // У нас два варианта, бежим по нарастающей от 0 до 255
  if (from < to) {
    while (c < to) {
      analogWrite(pin, c);
      c += 1;
      delay(10);
    }
  // Или бежим по убывающей от 255 до 0
  } else {
    while (c > to) {
      analogWrite(pin, c);
      c -= 1;
      delay(10);
    }
  }
  // Ждем секунду для закрепления цвета
  delay(1000);
}
```

Процедура на вход ожидает 3 числа:
1. Пин, у которого изменять значение.
2. Значение, которое установлено сейчас (или 0, или 255).
3. Значение, которое должно быть (или 255, или 0).

В процедуре мы смотрим в какую сторону бежим - по нарастающей или по убывающей и соответственно меняем значение. Ждем 10 мс для закрепления результата.

Теперь мы можем вызывать данную процедуру в коде программы:

```C++
void loop()
{
  analogWrite(RED, 255); // Красный (включим для первого запуска)
  smooth(BLUE, 0, 255);  // Фуксия (пурпурный) (R+B)
  smooth(RED, 255, 0);   // Синий (B)
  smooth(GREEN, 0, 255); // Сине-зеленый (G+B)
  smooth(BLUE, 255, 0);  // Зеленый (G)
  smooth(RED, 0, 255);   // Желтый (R+G)
  smooth(GREEN, 255, 0); // Красный (R)
}
```

Можно добавить еще переменную для управления скоростью смены цветов, чтобы вместо +1 или -1 цвет изменялся быстрее. Добавим переменную `speed`. Итоговый код:

```C++
#define RED 9
#define GREEN 11
#define BLUE 10

int speed = 5; // Скорость, с которой будет нарастать яркость

void setup()
{
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(BLUE, OUTPUT);
}

// Процедура для плавного перелива. Указываем с какого значения до какого
//  увеличивать (или уменьшать) значение на 1.
void smooth(int pin, int from, int to) {
  // Будем изменять переменную from до тех пор, пока она не станет равной переменной to
  // Сделаем копию переменной from, назовем ее c и будем работать с ней
  int c = from;
  // У нас два варианта, бежим по нарастающей от 0 до 255
  if (from < to) {
    while (c < to) {
      analogWrite(pin, c);
      c += speed;
      delay(10);
    }
  // Или бежим по убывающей от 255 до 0
  } else {
    while (c > to) {
      analogWrite(pin, c);
      c -= speed;
      delay(10);
    }
  }
  // Ждем секунду для закрепления цвета
  delay(1000 / speed);
}

void loop()
{
  analogWrite(RED, 255); // Красный (включим для первого запуска)
  smooth(BLUE, 0, 255);  // Фуксия (пурпурный) (R+B)
  smooth(RED, 255, 0);   // Синий (B)
  smooth(GREEN, 0, 255); // Сине-зеленый (G+B)
  smooth(BLUE, 255, 0);  // Зеленый (G)
  smooth(RED, 0, 255);   // Желтый (R+G)
  smooth(GREEN, 255, 0); // Красный (R)
}
```

![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/src/demo1.gif)

## Случайный цвет

Теперь цвет будем получать случайно. Будем по очереди получать случайное число от 0 до 255 для каждого из цветов: красного, зеленого и синего и будем бежать до полученного значения. Для хранения текущих значений для каждого из трех цветов добавим три переменные: `r` для красного, `g` для зеленого и `b` для синего. А также переменную `v` для временного хранения случайного числа.
Для получения случайного числа существует функция `random(x)`, которая вернет число от 0 до x-1. Мы будем вызывать функцию с параметром 256, чтобы получить случайные числа в диапазоне от 0 до 255.
Чтобы числа получались случайными при каждом запуске, будем слушать шумы с порта 0 (к которому ничего не подключено). Для подключения функции генерации случайных чисел будем использовать конструкцию `randomSeed(analogRead(0))` в блоке _setup_.

Получим следующий код:
```C++
#define RED 9
#define GREEN 11
#define BLUE 10

int speed = 5; // Скорость, с которой будет нарастать яркость
int r = 0;
int g = 0;
int b = 0;
int v;

void setup()
{
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(BLUE, OUTPUT);
  // Подключим генератор случайных чисел как уловитель шумов с пина 0
  randomSeed(analogRead(0));
}

// Процедура для плавного перелива. Указываем с какого значения до какого
//  увеличивать (или уменьшать) значение на 1.
void smooth(int pin, int from, int to) {
  // Будем изменять переменную from до тех пор, пока она не станет равной переменной to
  // Сделаем копию переменной from, назовем ее c и будем работать с ней
  int c = from;
  // У нас два варианта, бежим по нарастающей от 0 до 255
  if (from < to) {
    while (c < to) {
      analogWrite(pin, c);
      c += speed;
      delay(10);
    }
  // Или бежим по убывающей от 255 до 0
  } else {
    while (c > to) {
      analogWrite(pin, c);
      c -= speed;
      delay(10);
    }
  }
  // Ждем секунду для закрепления цвета
  delay(1000 / speed);
}

void loop()
{
  // Получаем случайный цвет для красного
  v = random(256);
  smooth(RED, r, v); 
  r = v; 
  // Получаем случайный цвет для зеленого
  v = random(256);
  smooth(GREEN, g, v);
  g = v;
  // Получаем случайный цвет для синего
  v = random(256);
  smooth(BLUE, b, v);
  b = v;
}
```
![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/src/demo2.gif)

## Работа с 7-сегментным индикатором.

7-сегментный индикатор это семь светодиодов, выстроенных в форме восьмерки. Также часто используется восьмой светодиод для отображения десятичной точки:

![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/src/img.png)

Индикатор имеет 10 ног. 8 ног - это "плюсы" каждого из восьми светодиодов, "минусы" всех светодиодов соединены в один вывод - девятый. Он же продублирован для удобства и в десятый (есть индикаторы, в которых наоборот, "минусы" каждого из восьми светодиодов - отдельные ноги, а плюсы объединены в одну). "Минусы" всех светодиодов - это центральные ноги сверху и снизу. В целом ноги примерно располагаются рядом со светодиодами. Верхний светодод зажигается 4й ногой сверху, верхний правый - 5й ногой. Нижний правый - 4й нога снизу, десятичная точка - 5я нога снизу. На картинке выше (в правой ее части) можно увидеть подробнее - земля - это ноги 3, 8. Буква a (верхний светодиод) - 7я нога и так далее.

Подключим к каждому из восьми выводов индикатора (кроме центральных) по резистору, а их к ардуино, к пинам с 2 по 9. Каждый пин настраиваем как OUTPUT. Любую из центральных ног подключаем к земле: 

![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/7c.png)

На схеме a - 2 пин, b - 3 пин, с - 4 пин, d - 6 пин, e - 7 пин, f - 9 пин, g - 8 пин, dp - 5 пин.

Для того, чтобы нарисовать цифру 1 на индикторе, необходимо зажечь два светодиода, расположенных справа - _b_, _c_, которые соединены с 3 и 4 пинами соответственно. Остальные пины нужно выключить. Аналогично и с другими цифрами. Для того, чтобы упростить работу в дальнейшем, создадим процедуры (10 штук для каждой цифры `g1`, `g2` ... `g0`), которые будут зажигать нужные цифры. Процедура для формирования цифры 1 будет выглядеть так:

```C++
void g1() {
  digitalWrite(2, LOW);
  digitalWrite(3, HIGH);
  digitalWrite(4, HIGH);
  digitalWrite(5, LOW);
  digitalWrite(6, LOW);
  digitalWrite(7, LOW);
  digitalWrite(8, LOW);
  digitalWrite(9, LOW);
}
```

А в основной программе сделаем цикл от 0 до 9, и будем вызывать нужную процедуру:

```C++
void loop()
{
  for (int i = 0; i <= 9; i++) {
    if (i==0) { g0(); }
    if (i==1) { g1(); }
    if (i==2) { g2(); }
    if (i==3) { g3(); }
    if (i==4) { g4(); }
    if (i==5) { g5(); }
    if (i==6) { g6(); }
    if (i==7) { g7(); }
    if (i==8) { g8(); }
    if (i==9) { g9(); }
    delay(500);
  }
}
```

Итоговый код доступен по [ссылке](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/7c.ino).

![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/src/demo3.gif)

## Оптимизируем код

Пины будем хранить в битовых масках. Каждое число или символ состоит из последовательности бит, которые можно вытащить по одному функцией `bitRead`. Бит содержит число 1 или 0. Преобразуем процедуру 
```C++
void g1() {
  digitalWrite(2, LOW);
  digitalWrite(3, HIGH);
  digitalWrite(4, HIGH);
  digitalWrite(5, LOW);
  digitalWrite(6, LOW);
  digitalWrite(7, LOW);
  digitalWrite(8, LOW);
  digitalWrite(9, LOW);
}
```
в последовательность битов, где LOW - это 0, а HIGH - это 1. Получим такую последовательность: 01100000. Для того, чтобы указать ардуино что это именно последовательность бит, а не число 1 100 000, необходимо в начале добавить _B_. Присвоим это значение переменной d1:
```C++
int d0 = B11101101;
int d1 = B01100000;
...
```
Теперь, чтобы зажечь цифру, нам необходимо брать по одному каждый бит и отправлять его в соответствующий ему пин. Из числа `B01100000` берем первый бит 0 и отправляем его во второй пин, далее берем второй бит 1 и отправляем его в третий пин, третий бит 1 отправляем в четвертый пин и т.д. Функция `bitRead` читает биты с конца (причем нумерует их не от 1 до 8, а от 0 до 7), т.е. если вызвать `bitRead(d1, 0)`, то функция вернет последний бит, если `bitRead(d1, 1)` - предпоследний.
Таким образом, чтобы зажечь цифру, зашифрованную в d1, необходимо выполнить следующий код:
```C++
digitalWrite(2, bitRead(d1, 7));
digitalWrite(3, bitRead(d1, 6));
digitalWrite(4, bitRead(d1, 5));
digitalWrite(5, bitRead(d1, 4));
digitalWrite(6, bitRead(d1, 3));
digitalWrite(7, bitRead(d1, 2));
digitalWrite(8, bitRead(d1, 1));
digitalWrite(9, bitRead(d1, 0));
```
Все это можно выполнить одним циклом:
```C++
for (int j = 0; j < 8; j++) {
  digitalWrite(9-j, bitRead(d1, j));
}
```
Аналогично и для других цифр. Данный цикл помещаем в процедуру `g1()`. Меням в цикле d1 на d2 и вот уже готовый код для процедуры `g2()`. И так далее.

Итоговый код доступен по [ссылке](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson7/7c2.ino).

## Оптимизируем далее

Теперь избавимся от процедур, т.к. код в них почти идентичен. Вместо десяти переменных d0..d9 воспользуемся одним массивом:
```C++
int d[] = {
  B11101101,
  B01100000,
  B11001110,
  B11101010,
  B01100011,
  B10101011,
  B10101111,
  B11100000,
  B11101111,
  B11101011,
};
```
Теперь мы можем обращаться к нашим бинарным маскам с помощью индекса: `d[0]` вернет `B11101101`, `d[1]` вернет `B01100000` и так далее. Теперь необходимость в условиях и процедурах отпала. Основную программу можно переписать так:
```C++
void loop()
{
  for (int i = 0; i <= 9; i++) {
    for (int j = 0; j < 8; j++) {
      digitalWrite(9-j, bitRead(d[i], j));
    }
    delay(500);
  }
}
```
Здесь `i` - число, которое нужно рисовать, битовая маска лежит в переменной `d[i]` (в массиве все позиции начинаются с нуля). 
Заодно и в процедуре _setup_ используем цикл, полный текст программы будет такой: 
```C++
/*
  2
9   3
  8
7   4
  6   5
*/

int d[] = {
  B11101101,
  B01100000,
  B11001110,
  B11101010,
  B01100011,
  B10101011,
  B10101111,
  B11100000,
  B11101111,
  B11101011,
};

void setup()
{
  for (int i = 2; i<=9; i++) {
    pinMode(i, OUTPUT);
  }
}

void loop()
{
  for (int i = 0; i <= 9; i++) {
    for (int j = 0; j < 8; j++) {
      digitalWrite(9-j, bitRead(d[i], j));
    }
    delay(500);
  }
}
```
