# Работа с пультом дистанционного управления

Пульт дистанционного управления - это источник инфракрасного излучения. Каждая кнопка пульта имеет свой уникальный код, который передается ИК-светодиодом в пульте.
![img](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/src/img1.jpg)

Для приема данного излучения используем приемники ИК. Они бывают разных видов и форм, у нас используются tsop 31236 и tsop 1838:

![img](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/src/img2.jpg)
![img](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/src/img3.jpg)

Подключение у них разное. В первом случае левые две ноги - земля и питание, а отдельно стоящая нога - выходной сигнал. Во втором случае левая нога - выходной сигнал, вторая - земля, третья - питание. На тинкеркад используется второй вариант.

![9a](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/9a.png)

Работать с указанными датчиками напряму с ардуино сложно, для простоты необходимо воспользоваться библиотекой `IRremote.h`. Библиотеки - специальные файлы, написанные сторонними программистами, которые можно подключать в адруино и пользоваться методами, разработанными в них. Мы уже пользовались библиотекой `Servo.h`, когда управляли сервоприводом. Библиотеки `IRremote.h` нет в стандартной поставке ардуино (вообще есть такая, расположенная в папке RobotIRremote, но если написать просто #include <IRremote.h> - ардуино ее не увидит). Ее необходимо скачать. Если вбить в поиске "IRremote.h", в первых ссылках будут: 
* https://github.com/z3t0/Arduino-IRremote
* https://www.arduinolibraries.info/libraries/i-rremote (которая ссылается на первую)

Напрямую архив можно скачать по второй ссылке, либо перейти по первой и найти блок "Installation" (Установка), в котором сказано:
1. Перейдите на страницу "Releases" (https://github.com/z3t0/Arduino-IRremote/releases). 
2. Загрузите последний релиз. (Файл IRremote.zip, на текущий момент самая последняя версия 2.4.0)
3. Распакуйте скачанный zip архив.
4. Переместите папку IRremote, которую распаковали, в папку с библиотеками для ардуино. (Папка с библиотеками ардуино находится по пути: C:\Program Files (x86)\Arduino\libraries)
5. Удалите папку RobotIRremote, с которой конфликтует данная библиотека. (Для целей обучения можно не удалять, работает и с ней).

Вместе с библиотекой идут примеры. Откроем пример "IRrecvDemo" проверим пин, к которому подключен выходной сигнал с датчика, укажем его в строке `int RECV_PIN = 11;` и запустим. Полный код:

```C++
#include <IRremote.h>

int RECV_PIN = 11;

IRrecv irrecv(RECV_PIN);

decode_results results;

void setup()
{
  Serial.begin(9600);
  Serial.println("Enabling IRin");
  irrecv.enableIRIn();
  Serial.println("Enabled IRin");
}

void loop() {
  if (irrecv.decode(&results)) {
    Serial.println(results.value, HEX);
    irrecv.resume(); 
  }
  delay(100);
}
```
![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/9a.gif)

Остановимся подробнее на коде. В первой строке подключается библиотека `IRremote.h`, которую мы скачали.
Далее объявляется переменная `RECV_PIN`, в которую присваивается 11 - это пин, к которому подключен ИК-приемник. Следующая строка объявляет переменную `irrecv` с типом `IRrecv` и инициализирует ее (сразу передается пин). Аналогично было и с сервоприводом (за исключением скобок). Четвертая строка объявляет переменную `results`, которая будет содержать полученный сигнал с пульта ДУ. В блоке установки инициализируется серийный порт (для того, чтобы мы могли видеть код каждой кнопки). Строки `Serial.println` в блоке `setup` можно исключить, они нужны для того, чтобы при возникновении ошибки понять где она появилась. Строка `irrecv.enableIRIn();` начинает процесс приемки сигнала (включает прерывания и прочее).
В основном цикле программы `irrecv.decode(&results)` пытается получить код и пульта ДУ (если кнопка не нажата, то и кода не будет). Функция вернет `true` если код получен, если код еще не получен, то вернет `false`. Когда код получен, вся информация о нем сохраняется в переменной `results`. Мы можем обратиться к пяти различным полям данной переменной, но на практике будем использоваться только `results.value` - код, полученный с пульта. Этот код мы передадим в монитор серийного порта. Обратите внимание на второй параметр `HEX`, который говорит, чтобы мы выводили код в шестнадцатеричном формате. На самом деле можно и в десятичном, просто лучше смотреть на числа в таком виде: FD08F7, FD8877, FD48B7, чем в соответствующим им виде: 16582903, 16615543 и 16599223.
После того как мы получили и обработали код, мы должны подготовить программу к приему нового кода, это делается командой `irrecv.resume();`
Если на пульте зажать и держать кнопку, то сначала ардуино получит код кнопки, а затем постоянно будет получать FFFFFFFF (в 16-ричной системе)
> В ардуино для того чтобы отличить число 10 от числа 10 в шестнадцеричной системе, необходимо добавить 0x перед числом в шестнадцатеричной системе. Т.е. 10 - это число 10 в десятичной системе, а 0х10 - это 10 в шестнадцатеричной системе, которое соответствует 16 в десятичной.

## Управление светодиодами с пульта ДУ

Добавим два светодиода к схеме (через резисторы 220Ом на пины 8 и 9). При нажатии на кнопку на пульте с цифрой 1 будем зажигать светодиод на пине 8 (красный), при нажатии на кнопку с цифрой 2 зажигаем светодиод на пине 9, при нажатии на кнопку с цифрой 0 - тушим оба светодиода. 

Для начала необходимо узнать коды для каждой из кнопок - 0, 1 и 2. Запустим программу, откроем монитор серийного порта и запишем полученные коды. Для каждого пульта ДУ коды могут быть разными. В моем случае это коды:
* 0 - FD30CF
* 1 - FD08F7
* 2 - FD8877

Далее добавим в программу логику по обработке данных кодов. Не забудем, что коды у нас в 16-ричном формате, поэтому добавим к ним 0x.
1. Добавим в блок `setup` две строки:
```C++
pinMode(8, OUTPUT);
pinMode(9, OUTPUT);
```
А в основном цикле программы `loop` (перед `irrecv.resume()`) добавим условия:
```C++
if (results.value == 0xFD30CF) {
  // Нажата кнопка 0, гасим оба светодиода
  digitalWrite(8, LOW);
  digitalWrite(9, LOW);
}
if (results.value == 0xFD08F7) {
  // Нажата кнопка 1, зажигаем красный:
  digitalWrite(8, HIGH);
}
if (results.value == 0xFD8877) {
  // Нажата кнопка 2, зажигаем зеленый:
  digitalWrite(9, HIGH);
}
```
Все, можно запускать, полный код программы:
```C++
#include "IRremote.h"

IRrecv irrecv(11); // указываем вывод, к которому подключен приемник

decode_results results;

void setup() {
  Serial.begin(9600); // выставляем скорость COM порта
  pinMode(8, OUTPUT);
  pinMode(9, OUTPUT);
  irrecv.enableIRIn(); // запускаем прием
}

void loop() {
  if ( irrecv.decode( &results )) { // если данные пришли
    Serial.println( results.value, HEX ); // печатаем данные
    if (results.value == 0xFD30CF) {
      // Нажата кнопка 0, гасим оба светодиода
      digitalWrite(8, LOW);
      digitalWrite(9, LOW);
    }
    if (results.value == 0xFD08F7) {
      // Нажата кнопка 1, зажигаем красный:
      digitalWrite(8, HIGH);
    }
    if (results.value == 0xFD8877) {
      // Нажата кнопка 2, зажигаем зеленый:
      digitalWrite(9, HIGH);
    }
    
    irrecv.resume(); // принимаем следующую команду
  }
}
```
![demo](https://github.com/trusiwko/Arduino/raw/master/eKids/Lesson9/9b.gif)
